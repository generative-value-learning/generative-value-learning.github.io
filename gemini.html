<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GVL Live Demo</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        input, textarea {
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
        }
        button {
            background: #0066ff;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }
        button:hover {
            background: #0052cc;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .result {
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-height: 100px;
            white-space: pre-wrap;
        }
        .error {
            color: #dc2626;
            display: none;
            margin-top: 1rem;
        }
        #imagePreview {
            max-width: 100%;
            max-height: 300px;
            margin-top: 1rem;
            display: none;
            object-fit: contain;
        }
        .progress {
            display: none;
            margin: 0.5rem 0;
        }
        .frame-container {
            position: relative;
            display: inline-block;
            margin: 1rem;
        }
        .frame-number {
            position: absolute;
            left: 5px;
            top: 5px;
            background: rgba(40, 167, 69, 0.5);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            transition: background 0.3s;
        }
        .frame-container:hover .frame-number {
            background: rgba(40, 167, 69, 0.7);
        }
        .shuffled-frame-number {
            position: absolute;
            right: 5px;
            top: 5px;
            background: rgba(255, 200, 200, 0.5);
            color: black;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            transition: background 0.3s;
        }
        .frame-container:hover .shuffled-frame-number {
            background: rgba(255, 200, 200, 0.9);
        }
        .order-buttons {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }
        .frame-progress {
            position: absolute;
            right: -10px;
            top: 0;
            width: 4px;
            background: #eee;
            height: 100%;
        }
        .frame-progress-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: #28a745;
            transition: height 0.3s ease;
        }
        .frame-description {
            position: absolute;
            left: 5px;
            bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            max-width: calc(100% - 20px);
            transition: background 0.3s;
        }
        .frame-container:hover .frame-description {
            background: rgba(0, 0, 0, 0.7);
        }
        #plotContainer {
            width: 100%;
            height: 400px;
            margin-top: 1rem;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="instructions">
            <p>Upload a video enter your Gemini API key and task description, then first shuffle it, and "Get Response" to analyze the frames. 
            </p>
            <p>After receiving the response, you can click "Parse Response" to see the predicted task completion percentage for each frame. You can toggle back to GT order to examine the predicted value function as well as the caption.</p>
        </div>
        <div class="input-group">
            <label for="apiKey">API Key:</label>
            <input type="password" id="apiKey" placeholder="Enter your API key">
        </div>

        <div class="input-group">
            <label for="taskDescription">Task Description:</label>
            <textarea id="taskDescription" rows="2" placeholder="Describe the robot task"></textarea>
        </div>

        <div class="input-group">
            <label for="imageInput">Upload Image:</label>
            <div style="margin-bottom: 0.5rem; font-size: 0.9rem; color: #666;">
                <span style="color: #28a745;">Green numbers</span> show ground truth frame order. 
                <span style="color: #dc3545;">Red numbers</span> show shuffled frame order.
            </div>
            <input type="file" id="imageInput" accept="image/*,video/*">
            <img id="imagePreview" alt="Preview">
            <div id="frameContainer" style="display: none; margin-top: 1rem;"></div>
            <div class="order-buttons" id="orderButtons" style="display: none;">
                <button onclick="orderFrames('gt')">Order by Ground Truth</button>
                <button onclick="orderFrames('shuffled')">Order by Shuffled</button>
            </div>
        </div>

        <button id="submitBtn" onclick="sendRequest()" disabled>Get Response</button>
        <button id="parseBtn" onclick="parseResponse()" style="margin-top: 0.5rem;" disabled>Parse Response</button>

        <div id="progress" class="progress">Processing request...</div>
        <div id="error" class="error"></div>
        <div id="result" class="result"></div>
        <div id="plotContainer"></div>
    </div>

    <script>
        const imageInput = document.getElementById('imageInput');
        const imagePreview = document.getElementById('imagePreview');
        const frameContainer = document.getElementById('frameContainer');
        const submitBtn = document.getElementById('submitBtn');
        const parseBtn = document.getElementById('parseBtn');
        const orderButtons = document.getElementById('orderButtons');
        const plotContainer = document.getElementById('plotContainer');
        let imageBase64 = null;
        let imageType = null;
        let frames = [];
        let isOrdered = false;
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function orderFrames(orderType) {
            const frameElements = Array.from(frameContainer.children);
            frameElements.sort((a, b) => {
                const aNum = parseInt(orderType === 'gt' ? 
                    a.querySelector('.frame-number').textContent :
                    a.querySelector('.shuffled-frame-number').textContent);
                const bNum = parseInt(orderType === 'gt' ? 
                    b.querySelector('.frame-number').textContent :
                    b.querySelector('.shuffled-frame-number').textContent);
                return aNum - bNum;
            });
            
            frameContainer.innerHTML = '';
            frameElements.forEach(frame => frameContainer.appendChild(frame));
            isOrdered = orderType === 'gt';
            
            // Enable/disable buttons based on order
            submitBtn.disabled = isOrdered;
            parseBtn.disabled = isOrdered;
        }
        
        function extractJSON(text) {
            const codeBlockMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (codeBlockMatch) {
                return codeBlockMatch[1];
            }

            const arrayMatch = text.match(/\[\s*{[\s\S]*}\s*\]/);
            if (arrayMatch) {
                return arrayMatch[0];
            }

            return null;
        }

        function parseResponse() {
            const resultDiv = document.getElementById('result');
            const errorDiv = document.getElementById('error');
            const responseText = resultDiv.textContent;

            if (isOrdered) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Frames must be in shuffled order to parse response';
                return;
            }

            try {
                const jsonText = extractJSON(responseText);
                if (!jsonText) {
                    throw new Error('No valid JSON found in response');
                }

                const parsedFrames = JSON.parse(jsonText);
                parsedFrames.forEach(frame => {
                    const frameEl = frameContainer.children[frame.frame_number - 1];
                    if (frameEl) {
                        const progressFill = frameEl.querySelector('.frame-progress-fill');
                        const description = frameEl.querySelector('.frame-description');
                        progressFill.style.height = `${frame.task_completion_percentage}%`;
                        description.textContent = frame.frame_description;
                    }
                });

                // Create plot data
                const sortedFrames = [...parsedFrames].sort((a, b) => {
                    const aGt = parseInt(frameContainer.children[a.frame_number - 1].querySelector('.frame-number').textContent);
                    const bGt = parseInt(frameContainer.children[b.frame_number - 1].querySelector('.frame-number').textContent);
                    return aGt - bGt;
                });

                const plotData = [{
                    x: sortedFrames.map((_, i) => i + 1),
                    y: sortedFrames.map(f => f.task_completion_percentage),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Predicted Progress'
                }];

                const layout = {
                    title: 'Task Completion Progress',
                    xaxis: {
                        title: 'GT Frame Order',
                        tickmode: 'linear'
                    },
                    yaxis: {
                        title: 'Gemini Predicted Value Function',
                        range: [0, 100]
                    }
                };

                plotContainer.style.display = 'block';
                Plotly.newPlot('plotContainer', plotData, layout);

                errorDiv.style.display = 'none';
            } catch (e) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = `Error parsing response: ${e.message}`;
            }
        }
        
        imageInput.addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (file.type.startsWith('video/')) {
                // Handle video file
                const video = document.createElement('video');
                video.src = URL.createObjectURL(file);
                
                video.onloadedmetadata = function() {
                    frameContainer.innerHTML = ''; // Clear previous frames
                    frameContainer.style.display = 'block';
                    orderButtons.style.display = 'flex';
                    imagePreview.style.display = 'none';
                    plotContainer.style.display = 'none';
                    isOrdered = false;
                    submitBtn.disabled = false;
                    parseBtn.disabled = false;
                    
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    
                    // Calculate frame count based on video duration
                    let frameCount;
                    let frameInterval;
                    if (video.duration <= 30) {
                        frameCount = Math.floor(video.duration);
                        frameInterval = 1;
                    } else {
                        frameCount = 30;
                        frameInterval = video.duration / 30;
                    }
                    
                    // Create shuffled frame numbers
                    const shuffledNumbers = shuffleArray([...Array(frameCount)].map((_, i) => i + 1));
                    
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    let currentFrame = 0;
                    video.currentTime = 0;
                    
                    video.onseeked = function() {
                        context.drawImage(video, 0, 0);
                        const frameWrapper = document.createElement('div');
                        frameWrapper.className = 'frame-container';
                        
                        const frameImg = document.createElement('img');
                        frameImg.src = canvas.toDataURL('image/jpeg');
                        frameImg.style.width = '150px';
                        frameImg.style.margin = '5px';
                        frameImg.onclick = function() {
                            imageBase64 = frameImg.src.split(',')[1];
                            imageType = 'image/jpeg';
                        };
                        
                        const frameNumber = document.createElement('div');
                        frameNumber.className = 'frame-number';
                        frameNumber.textContent = `${currentFrame + 1}`;
                        
                        const shuffledFrameNumber = document.createElement('div');
                        shuffledFrameNumber.className = 'shuffled-frame-number';
                        shuffledFrameNumber.textContent = `${shuffledNumbers[currentFrame]}`;
                        
                        const progressBar = document.createElement('div');
                        progressBar.className = 'frame-progress';
                        const progressFill = document.createElement('div');
                        progressFill.className = 'frame-progress-fill';
                        progressBar.appendChild(progressFill);
                        
                        const description = document.createElement('div');
                        description.className = 'frame-description';
                        
                        frameWrapper.appendChild(frameImg);
                        frameWrapper.appendChild(frameNumber);
                        frameWrapper.appendChild(shuffledFrameNumber);
                        frameWrapper.appendChild(progressBar);
                        frameWrapper.appendChild(description);
                        frameContainer.appendChild(frameWrapper);
                        
                        currentFrame++;
                        if (currentFrame < frameCount) {
                            video.currentTime = currentFrame * frameInterval;
                        }
                    };
                };
            } else {
                // Handle image file
                frameContainer.style.display = 'none';
                orderButtons.style.display = 'none';
                plotContainer.style.display = 'none';
                imageType = file.type;
                const reader = new FileReader();
                reader.onload = function(e) {
                    imagePreview.src = e.target.result;
                    imagePreview.style.display = 'block';
                    imageBase64 = e.target.result.split(',')[1];
                };
                reader.readAsDataURL(file);
            }
        });
        async function sendRequest() {
            const apiKey = document.getElementById('apiKey').value;
            const taskDescription = document.getElementById('taskDescription').value;
            const resultDiv = document.getElementById('result');
            const errorDiv = document.getElementById('error');
            const progressDiv = document.getElementById('progress');

            if (!apiKey || !taskDescription) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Please provide API key and task description';
                return;
            }

            // Get all frame images in current order
            const frameImages = Array.from(frameContainer.getElementsByTagName('img'));
            if (frameImages.length === 0) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Please provide video frames';
                return;
            }

            if (isOrdered) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Frames must be in shuffled order to get response';
                return;
            }

            errorDiv.style.display = 'none';
            resultDiv.textContent = '';
            progressDiv.style.display = 'block';
            submitBtn.disabled = true;

            try {
                const prompt = `You are an expert roboticist tasked to predict task completion percentages for frames of a robot for the task of ${taskDescription}. The task completion percentages are between 0 and 100, where 100 corresponds to full task completion. We provide several examples of the robot performing the task at various stages and their corresponding task completion percentages. Note that these frames are in random order, so please pay attention to the individual frames when reasoning about task completion percentage.

Initial robot scene:
In the initial robot scene, the task completion percentage is 0.

Now, for the task of *${taskDescription}*, output the task completion percentage for the following frames that are presented in random order. Format your response as follow in json format, make sure to include all frames:

[
{"frame_number": i, "frame_description": "...", "task_completion_percentage": (0-100)}
]`;
                console.log(prompt);
                // Prepare parts array with prompt and all frames
                const parts = [
                    {
                        text: prompt
                    }
                ];
                console.log(prompt);

                // Add all frames to parts array with frame number prefix
                frameImages.forEach((frameImg, i) => {
                    parts.push({
                        text: `Frame ${i + 1}:`
                    });
                    parts.push({
                        inline_data: {
                            mime_type: 'image/jpeg',
                            data: frameImg.src.split(',')[1]
                        }
                    });
                });

                // Make single API request with all frames
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: parts
                            }]
                        })
                    }
                );

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error?.message || 'API request failed');
                }

                const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
                resultDiv.textContent = responseText;

            } catch (error) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = `Error: ${error.message}`;
                resultDiv.textContent = '';
            } finally {
                progressDiv.style.display = 'none';
                submitBtn.disabled = isOrdered;
            }
        }

    </script>
</body>
</html>
